## fun.c
I remembered watching a youtube video about the game fizzbuzz. I originally
wanted to implement a solution such that it provides/generates the first N
associated values/words, but never got to it. It was probably due to laziness or
just wasn't motivated enough attempt it myself. But since I wanted to remind
myself of how allocating and freeing memory works in C, and how to dynamically
allocate and free an array of strings (char**) in C.

[ Well, I eventually got to it and implemented it... Also, I didn't really look
into the details fizzbuzz too much, there could be something I missed or
misread. And Similarly for checking for memory leaks on Valgrind. Sooooooo......
double check the reference..... And I might or might not update this in the
future... ]

## invert_binary_tree.c
I remembered hearing about from friends who were in the CO-OP program and some
classmates (who most likely were in the CO-OP program as well, or were just one
of those gifted people who likes to read up on interesting problems and
instantly, without any effort at all, just solves them...), talked about
inverted binary trees. And just recently, a random video appeared on my YouTube
recommendations. The video was a nice little skit on the common experiences
faced in a developer job interview. Mostly on about providing and implementing
solutions to simple to moderately hard problems with the fastest possible time
(and potentially space) complexity. And In the video, it briefly mentioned about
"inverting binary tree" in the intro, and was never explained. Well, after some
googling, it turns out that inverted binary trees is in fact a thing.
The definition of a inverted binary tree is literally swapping the left branch
with the right branch of a regular binary tree. So basically, after inverting a
regular binary tree, the left branch represents the larger key values than the
root/parent key and the opposite with the right branch).

[ I seriously laughed when I heard about the idea of inverting a binary tree.
Like how can that be a thing, and how can it be inverted in anyway. Well...
Turns out when expressing a binary tree's mathematical relational definition and
negating it, the opposite relation can be viewed as the inverted relation. Or at
least I think so... Else, I seriously need to slam my head back into my notes on
Mathematical Logic... Like I passed that course even when I was between 2 to 3
weeks late in the course, seriously I was LOL ]

## reverse_linked_list.c
In the same video from above, it also talked about reversing a linked list. I
had initially and originally done this before. It was for some random
assignment, and also out of curiosity when I was bored and had forgotten how to
do it in C.

[ Well, I thought I should add it here. As it would be great place to reference
back to it again. And it is so that I can stop re-coding the same thing over and
over again... Also, in functional programming languages like Scheme, Racket,
CommonLisp and Haskell does this better, as it can be expressed as an explicit
relation, much like a mathematical recursive relation. Just saying =) ]
